# 参考项目对比与设计取舍（Reseer-main / kose_seer / Seer-golang）

## 1. Reseer-main（Lua/Luvit 为主）
**要点**
- 协议栈清晰：`packet`/`bytebuffer`/`handlers` 把封包头与命令分发拆开，便于对齐 AS3 客户端。  
- 服务端逻辑极简，更多是「跑通流程」的最小实现；缺少持久化与配置治理。

**可借鉴点**
- 包头 17 字节结构（Len + Version + Cmd + UserId + Result）与 Lua 客户端完全一致。
- 处理逻辑以命令号为核心的分发模型，利于逐条补齐协议。

**问题点**
- 缺少工程化与可维护性保障；缺少配置版本管理/权限审计等 GM 必需功能。
- 缺少完整数据模型与数据库层，不利于数据一致性与扩展。

## 2. kose_seer（TypeScript 单体 GameServer）
**要点**
- 统一架构（所有功能合并在 GameServer），减少服务拆分复杂度。
- GM 后台能力丰富，包含玩家/精灵/地图配置等可视化功能。
- 数据层采用「Data 类直映数据库 + 延迟批量保存」，强调性能。

**优点**
- 统一服务降低部署复杂度，且 GM 后台设计完善。
- 多响应模式能还原原客户端一些「一发多回包」的行为。

**问题点（需规避）**
- 单体服务易演化成“全局状态+脚本式逻辑”，扩展和维护成本高。
- 延迟批量写入策略若无严格一致性/事务保护，容易引发数据竞态与回滚困难。
- TS/Node 的单线程模型在高并发战斗/地图广播等场景中容易成为瓶颈。

## 3. Seer-golang（Go 重构版）
**要点**
- 以 Go 网络模型实现多服务（登录/资源/游戏），使用 Gorm + MySQL。
- 大量 CMD 已具备“占位包体”策略，降低客户端报错概率。

**优点**
- 命令分发结构清晰；能较快对齐 Lua 的协议接口面。
- 登录/资源/游戏分离的结构有利于后续扩展。

**问题点（需规避）**
- ORM 选择与 DB 支持单一（仅 MySQL + Gorm），不符合多引擎要求。
- 缺少统一配置中心与 GM 版本治理；协议实现存在「占位」较多。
- 缺少系统性可观测性（审计、追踪、指标）。

## 4. jseer 设计取舍
**架构选择**
- 网络层：保留 TCP 网关（协议对齐）+ HTTP/Iris（资源/GM）双栈架构。  
- 数据层：使用 Ent ORM + 多数据库驱动（MySQL/SQLite/PostgreSQL）。  
- GM：独立 Vue3 + Vite 项目 + RBAC + 配置版本/审计日志。

**策略**
- 协议先对齐“可跑通”与“空/占位响应”策略，再逐条还原真实业务逻辑。
- 服务端强约束数据模型，避免“全局可变状态”扩散。
- 配置平台提供版本回滚、实时生效、权限分级、操作日志。

**需要后续逐步补齐的重点**
- Lua 客户端各 CMD 的完整协议体（含战斗、精灵、活动、经济系统）。
- 完整数据迁移与灰度发布工具链。
- 跨进程配置推送与事件总线（如 Redis/NATS）。
